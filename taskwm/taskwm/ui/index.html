<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>taskwm - Tasks</title>
    <style>
        :root {
            --bg: #111111;
            --fg: #e6e6e6;
            --accent: #66aaff;
            --button-bg: #222222;
            --entry-bg: #1a1a1a;
            --select-bg: #333333;
            --border: #333333;
            --muted: #666666;
            --danger: #aa4444;
            --danger-dim: #664444;
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: monospace;
            font-size: 13px;
            background: var(--bg);
            color: var(--fg);
            height: 100vh;
            overflow: hidden;
        }

        task-app {
            display: flex;
            flex-direction: column;
            height: 100vh;
            padding: 10px;
        }
    </style>
</head>
<body>
    <task-app></task-app>

    <script type="module">
        import { LitElement, html, css } from 'https://cdn.jsdelivr.net/npm/lit@3/+esm';

        // API wrapper
        class TaskAPI {
            constructor() {
                this.ready = false;
                this.readyPromise = this.waitForAPI();
            }

            async waitForAPI() {
                for (let i = 0; i < 50; i++) {
                    if (window.pywebview && window.pywebview.api) {
                        this.ready = true;
                        return true;
                    }
                    await new Promise(r => setTimeout(r, 100));
                }
                console.error('pywebview API not available');
                return false;
            }

            async call(method, ...args) {
                await this.readyPromise;
                if (!this.ready) return null;
                try {
                    return await window.pywebview.api[method](...args);
                } catch (e) {
                    console.error(`API call ${method} failed:`, e);
                    return null;
                }
            }

            getTasks() { return this.call('get_tasks'); }
            getCurrentTaskId() { return this.call('get_current_task_id'); }
            getConfig() { return this.call('get_config'); }
            addTask(title) { return this.call('add_task', title); }
            selectTask(id) { return this.call('select_task', id); }
            closeTask(id) { return this.call('close_task', id); }
            moveTaskUp(id) { return this.call('move_task_up', id); }
            moveTaskDown(id) { return this.call('move_task_down', id); }
            getWindowCount(taskId) { return this.call('get_window_count', taskId); }
            reorderTask(id, newIndex) { return this.call('reorder_task', id, newIndex); }
        }

        const api = new TaskAPI();

        // Task Row Component
        class TaskRow extends LitElement {
            static properties = {
                task: { type: Object },
                isCurrent: { type: Boolean },
                isSelected: { type: Boolean },
                winCount: { type: Number },
                confirming: { type: Boolean },
                dragging: { type: Boolean },
                dragOver: { type: Boolean },
            };

            static styles = css`
                :host {
                    display: block;
                }

                .task-row {
                    display: flex;
                    align-items: center;
                    padding: 6px 8px;
                    gap: 8px;
                    transition: background 0.1s;
                }

                .task-row:hover {
                    background: var(--select-bg);
                }

                .task-row.selected {
                    background: var(--select-bg);
                }

                .task-row.dragging {
                    opacity: 0.5;
                }

                .task-row.drag-over {
                    border-top: 2px solid var(--accent);
                }

                .drag-handle {
                    cursor: grab;
                    color: #444;
                    padding: 2px 4px;
                    font-size: 14px;
                    user-select: none;
                }

                .drag-handle:hover {
                    color: #666;
                }

                .drag-handle:active {
                    cursor: grabbing;
                }

                .task-title {
                    flex: 1;
                    font-size: 16px;
                    cursor: pointer;
                    white-space: nowrap;
                    overflow: hidden;
                    text-overflow: ellipsis;
                    color: var(--fg);
                }

                .task-title.current {
                    color: var(--accent);
                }

                .indicator {
                    display: inline-block;
                    width: 20px;
                }

                .win-count {
                    color: var(--muted);
                    font-size: 14px;
                    min-width: 35px;
                    text-align: right;
                }

                .controls {
                    display: flex;
                    align-items: center;
                    gap: 4px;
                }

                .ctrl-btn {
                    color: #555;
                    cursor: pointer;
                    padding: 2px 4px;
                    font-size: 18px;
                    user-select: none;
                }

                .ctrl-btn:hover {
                    color: #888;
                }

                .ctrl-btn.select {
                    color: #888;
                    font-size: 14px;
                }

                .ctrl-btn.select:hover {
                    color: var(--accent);
                }

                .ctrl-btn.close {
                    color: var(--danger-dim);
                    font-size: 14px;
                }

                .ctrl-btn.close:hover {
                    color: var(--danger);
                }

                .confirm-bar {
                    display: flex;
                    align-items: center;
                    gap: 8px;
                }

                .confirm-bar .msg {
                    color: #ff6666;
                    font-size: 12px;
                }

                .confirm-bar .yes {
                    color: #ff6666;
                    cursor: pointer;
                }

                .confirm-bar .yes:hover {
                    color: #ff8888;
                }

                .confirm-bar .no {
                    color: #888;
                    cursor: pointer;
                }

                .confirm-bar .no:hover {
                    color: #aaa;
                }
            `;

            constructor() {
                super();
                this.confirming = false;
                this.dragging = false;
                this.dragOver = false;
            }

            render() {
                const title = this.task.title.length > 50
                    ? this.task.title.slice(0, 47) + '...'
                    : this.task.title;

                return html`
                    <div class="task-row ${this.isSelected ? 'selected' : ''} ${this.dragging ? 'dragging' : ''} ${this.dragOver ? 'drag-over' : ''}"
                         draggable="true"
                         @dragstart=${this._onDragStart}
                         @dragend=${this._onDragEnd}
                         @dragover=${this._onDragOver}
                         @dragleave=${this._onDragLeave}
                         @drop=${this._onDrop}>
                        <span class="drag-handle">⠿</span>
                        <span class="task-title ${this.isCurrent ? 'current' : ''}" @click=${this._onSelect}>
                            <span class="indicator">${this.isCurrent ? '▶' : ''}</span>
                            ${title}
                        </span>
                        <span class="win-count">${this.winCount}w</span>
                        ${this.confirming ? this._renderConfirm() : this._renderControls()}
                    </div>
                `;
            }

            _renderControls() {
                return html`
                    <div class="controls">
                        <span class="ctrl-btn" @click=${this._onMoveUp}>↑</span>
                        <span class="ctrl-btn" @click=${this._onMoveDown}>↓</span>
                        <span class="ctrl-btn select" @click=${this._onSelect}>[Select]</span>
                        <span class="ctrl-btn close" @click=${this._onClose}>[Close]</span>
                    </div>
                `;
            }

            _renderConfirm() {
                return html`
                    <div class="confirm-bar">
                        <span class="msg">Close ${this.winCount}w?</span>
                        <span class="yes" @click=${this._onConfirmYes}>[Yes]</span>
                        <span class="no" @click=${this._onConfirmNo}>[No]</span>
                    </div>
                `;
            }

            _onDragStart(e) {
                this.dragging = true;
                e.dataTransfer.effectAllowed = 'move';
                e.dataTransfer.setData('text/plain', this.task.id.toString());
                this.dispatchEvent(new CustomEvent('drag-start', { detail: { taskId: this.task.id } }));
            }

            _onDragEnd() {
                this.dragging = false;
                this.dispatchEvent(new CustomEvent('drag-end'));
            }

            _onDragOver(e) {
                e.preventDefault();
                e.dataTransfer.dropEffect = 'move';
                this.dragOver = true;
            }

            _onDragLeave() {
                this.dragOver = false;
            }

            _onDrop(e) {
                e.preventDefault();
                this.dragOver = false;
                const draggedId = parseInt(e.dataTransfer.getData('text/plain'), 10);
                if (draggedId !== this.task.id) {
                    this.dispatchEvent(new CustomEvent('task-drop', {
                        detail: { draggedId, targetId: this.task.id },
                        bubbles: true, composed: true
                    }));
                }
            }

            _onSelect() {
                this.dispatchEvent(new CustomEvent('task-select', { detail: { taskId: this.task.id }, bubbles: true, composed: true }));
            }

            _onClose() {
                if (this.winCount > 0) {
                    this.confirming = true;
                } else {
                    this.dispatchEvent(new CustomEvent('task-close', { detail: { taskId: this.task.id }, bubbles: true, composed: true }));
                }
            }

            _onConfirmYes() {
                this.confirming = false;
                this.dispatchEvent(new CustomEvent('task-close', { detail: { taskId: this.task.id }, bubbles: true, composed: true }));
            }

            _onConfirmNo() {
                this.confirming = false;
            }

            _onMoveUp() {
                this.dispatchEvent(new CustomEvent('task-move-up', { detail: { taskId: this.task.id }, bubbles: true, composed: true }));
            }

            _onMoveDown() {
                this.dispatchEvent(new CustomEvent('task-move-down', { detail: { taskId: this.task.id }, bubbles: true, composed: true }));
            }
        }
        customElements.define('task-row', TaskRow);

        // Main App Component
        class TaskApp extends LitElement {
            static properties = {
                tasks: { type: Array },
                currentTaskId: { type: Number },
                selectedIndex: { type: Number },
                windowCounts: { type: Object },
                newTaskTitle: { type: String },
            };

            static styles = css`
                :host {
                    display: flex;
                    flex-direction: column;
                    height: 100vh;
                    padding: 10px;
                }

                .top-bar {
                    display: flex;
                    gap: 10px;
                    margin-bottom: 10px;
                }

                .top-bar input {
                    flex: 1;
                    background: var(--entry-bg);
                    border: 1px solid var(--border);
                    color: var(--fg);
                    padding: 8px 12px;
                    font-family: inherit;
                    font-size: inherit;
                    outline: none;
                }

                .top-bar input:focus {
                    border-color: var(--accent);
                }

                .top-bar button {
                    background: var(--button-bg);
                    border: none;
                    color: var(--fg);
                    padding: 8px 16px;
                    font-family: inherit;
                    font-size: inherit;
                    cursor: pointer;
                }

                .top-bar button:hover {
                    background: var(--accent);
                    color: #000;
                }

                .task-list {
                    flex: 1;
                    overflow-y: auto;
                }

                .task-list::-webkit-scrollbar {
                    width: 8px;
                }

                .task-list::-webkit-scrollbar-track {
                    background: var(--bg);
                }

                .task-list::-webkit-scrollbar-thumb {
                    background: var(--border);
                    border-radius: 4px;
                }

                .task-list::-webkit-scrollbar-thumb:hover {
                    background: #444;
                }
            `;

            constructor() {
                super();
                this.tasks = [];
                this.currentTaskId = null;
                this.selectedIndex = 0;
                this.windowCounts = {};
                this.newTaskTitle = '';
                this._init();
            }

            async _init() {
                await api.readyPromise;
                await this._applyTheme();
                await this._refresh();
                this._startPolling();
                this._setupKeyboardShortcuts();
            }

            async _applyTheme() {
                const config = await api.getConfig();
                if (config?.theme) {
                    const root = document.documentElement;
                    const t = config.theme;
                    if (t.bg) root.style.setProperty('--bg', t.bg);
                    if (t.fg) root.style.setProperty('--fg', t.fg);
                    if (t.accent) root.style.setProperty('--accent', t.accent);
                    if (t.button_bg) root.style.setProperty('--button-bg', t.button_bg);
                    if (t.entry_bg) root.style.setProperty('--entry-bg', t.entry_bg);
                    if (t.select_bg) root.style.setProperty('--select-bg', t.select_bg);
                    if (t.border) root.style.setProperty('--border', t.border);
                }
            }

            async _refresh() {
                this.tasks = await api.getTasks() || [];
                this.currentTaskId = await api.getCurrentTaskId();

                if (this.selectedIndex >= this.tasks.length) {
                    this.selectedIndex = Math.max(0, this.tasks.length - 1);
                }

                // Update window counts
                const counts = {};
                for (const task of this.tasks) {
                    counts[task.id] = await api.getWindowCount(task.id) || 0;
                }
                this.windowCounts = counts;
            }

            _startPolling() {
                setInterval(async () => {
                    const newTasks = await api.getTasks() || [];
                    const newCurrentId = await api.getCurrentTaskId();

                    const tasksChanged = JSON.stringify(newTasks) !== JSON.stringify(this.tasks);

                    if (tasksChanged) {
                        this.tasks = newTasks;
                        this.currentTaskId = newCurrentId;
                        if (this.selectedIndex >= this.tasks.length) {
                            this.selectedIndex = Math.max(0, this.tasks.length - 1);
                        }
                    } else if (newCurrentId !== this.currentTaskId) {
                        this.currentTaskId = newCurrentId;
                    }

                    // Update window counts
                    const counts = {};
                    for (const task of this.tasks) {
                        counts[task.id] = await api.getWindowCount(task.id) || 0;
                    }
                    this.windowCounts = counts;
                }, 500);
            }

            _setupKeyboardShortcuts() {
                document.addEventListener('keydown', (e) => {
                    const input = this.shadowRoot.querySelector('input');
                    const isInInput = e.target.tagName === 'INPUT';

                    if (e.key === 'ArrowUp' && !isInInput) {
                        e.preventDefault();
                        if (this.selectedIndex > 0) this.selectedIndex--;
                    } else if (e.key === 'ArrowDown' && !isInInput) {
                        e.preventDefault();
                        if (this.selectedIndex < this.tasks.length - 1) this.selectedIndex++;
                    } else if (e.key === 'Enter') {
                        if (isInInput && this.newTaskTitle.trim()) {
                            this._addTask();
                        } else if (!isInInput && this.tasks.length > 0) {
                            this._selectTask(this.tasks[this.selectedIndex].id);
                        }
                    } else if (e.key === 'Delete' || (e.ctrlKey && e.key === 'd')) {
                        if (!isInInput && this.tasks.length > 0) {
                            e.preventDefault();
                            this._closeTask(this.tasks[this.selectedIndex].id);
                        }
                    } else if (e.ctrlKey && e.key === 'n') {
                        e.preventDefault();
                        input?.focus();
                    } else if (e.key === 'Escape') {
                        if (this.newTaskTitle) {
                            this.newTaskTitle = '';
                        } else {
                            input?.blur();
                        }
                    }
                });
            }

            render() {
                return html`
                    <div class="top-bar">
                        <input
                            type="text"
                            placeholder="New task..."
                            .value=${this.newTaskTitle}
                            @input=${e => this.newTaskTitle = e.target.value}
                        >
                        <button @click=${this._addTask}>+</button>
                    </div>
                    <div class="task-list"
                         @task-select=${this._onTaskSelect}
                         @task-close=${this._onTaskClose}
                         @task-move-up=${this._onTaskMoveUp}
                         @task-move-down=${this._onTaskMoveDown}
                         @task-drop=${this._onTaskDrop}>
                        ${this.tasks.map((task, index) => html`
                            <task-row
                                .task=${task}
                                .isCurrent=${task.id === this.currentTaskId}
                                .isSelected=${index === this.selectedIndex}
                                .winCount=${this.windowCounts[task.id] || 0}
                            ></task-row>
                        `)}
                    </div>
                `;
            }

            async _addTask() {
                if (!this.newTaskTitle.trim()) return;
                await api.addTask(this.newTaskTitle.trim());
                this.newTaskTitle = '';
                await this._refresh();
            }

            async _selectTask(taskId) {
                await api.selectTask(taskId);
                await this._refresh();
            }

            async _closeTask(taskId) {
                await api.closeTask(taskId);
                await this._refresh();
            }

            async _onTaskSelect(e) {
                await this._selectTask(e.detail.taskId);
            }

            async _onTaskClose(e) {
                await this._closeTask(e.detail.taskId);
            }

            async _onTaskMoveUp(e) {
                await api.moveTaskUp(e.detail.taskId);
                await this._refresh();
            }

            async _onTaskMoveDown(e) {
                await api.moveTaskDown(e.detail.taskId);
                await this._refresh();
            }

            async _onTaskDrop(e) {
                const { draggedId, targetId } = e.detail;
                const targetIndex = this.tasks.findIndex(t => t.id === targetId);
                if (targetIndex >= 0) {
                    await api.reorderTask(draggedId, targetIndex);
                    await this._refresh();
                }
            }
        }
        customElements.define('task-app', TaskApp);
    </script>
</body>
</html>
