<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>taskwm - Tasks</title>
    <style>
        :root {
            --bg: #111111;
            --fg: #e6e6e6;
            --accent: #66aaff;
            --button-bg: #222222;
            --entry-bg: #1a1a1a;
            --select-bg: #333333;
            --border: #333333;
            --muted: #666666;
            --danger: #aa4444;
            --danger-dim: #664444;
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: monospace;
            font-size: 13px;
            background: var(--bg);
            color: var(--fg);
            height: 100vh;
            overflow: hidden;
        }

        /* Global select styling */
        select {
            background: var(--entry-bg);
            color: var(--fg);
            border: 1px solid var(--border);
            border-radius: 0;
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
        }

        select option {
            background: var(--entry-bg);
            color: var(--fg);
        }

        task-app {
            display: flex;
            flex-direction: column;
            height: 100vh;
            padding: 10px;
        }
    </style>
</head>
<body>
    <task-app></task-app>

    <script type="module">
        import { LitElement, html, css } from 'https://cdn.jsdelivr.net/npm/lit@3/+esm';

        const SIZES = ['S', 'M', 'L'];
        const SIZE_ORDER = { 'S': 1, 'M': 2, 'L': 3 };

        // API wrapper
        class TaskAPI {
            constructor() {
                this.ready = false;
                this.readyPromise = this.waitForAPI();
            }

            async waitForAPI() {
                for (let i = 0; i < 50; i++) {
                    if (window.pywebview && window.pywebview.api) {
                        this.ready = true;
                        return true;
                    }
                    await new Promise(r => setTimeout(r, 100));
                }
                console.error('pywebview API not available');
                return false;
            }

            async call(method, ...args) {
                await this.readyPromise;
                if (!this.ready) return null;
                try {
                    return await window.pywebview.api[method](...args);
                } catch (e) {
                    console.error(`API call ${method} failed:`, e);
                    return null;
                }
            }

            getTasks() { return this.call('get_tasks'); }
            getCurrentTaskId() { return this.call('get_current_task_id'); }
            getConfig() { return this.call('get_config'); }
            addTask(title) { return this.call('add_task', title); }
            selectTask(id) { return this.call('select_task', id); }
            closeTask(id) { return this.call('close_task', id); }
            moveTaskUp(id) { return this.call('move_task_up', id); }
            moveTaskDown(id) { return this.call('move_task_down', id); }
            getWindowCount(taskId) { return this.call('get_window_count', taskId); }
            reorderTask(id, newIndex) { return this.call('reorder_task', id, newIndex); }
            renameTask(id, newTitle) { return this.call('rename_task', id, newTitle); }
            setTaskSize(id, size) { return this.call('set_task_size', id, size); }
            setTaskCategory(id, categoryId) { return this.call('set_task_category', id, categoryId); }
            getCategories() { return this.call('get_categories'); }
            addCategory(name, color) { return this.call('add_category', name, color); }
            updateCategory(id, name, color) { return this.call('update_category', id, name, color); }
            removeCategory(id) { return this.call('remove_category', id); }
        }

        const api = new TaskAPI();

        // Task Row Component
        class TaskRow extends LitElement {
            static properties = {
                task: { type: Object },
                categories: { type: Array },
                isCurrent: { type: Boolean },
                isSelected: { type: Boolean },
                winCount: { type: Number },
                confirming: { type: Boolean },
                editing: { type: Boolean },
                editTitle: { type: String },
                dragging: { type: Boolean },
                dragOver: { type: Boolean },
                sizePickerOpen: { type: Boolean },
            };

            static styles = css`
                :host {
                    display: block;
                }

                .task-row {
                    display: flex;
                    align-items: center;
                    padding: 6px 8px;
                    gap: 8px;
                    transition: background 0.1s;
                    border-left: 4px solid transparent;
                }

                .task-row:hover {
                    background: var(--select-bg);
                }

                .task-row.selected {
                    background: var(--select-bg);
                }

                .task-row.dragging {
                    opacity: 0.5;
                }

                .task-row.drag-over {
                    border-top: 2px solid var(--accent);
                }

                .drag-handle {
                    cursor: grab;
                    color: #444;
                    padding: 2px 4px;
                    font-size: 14px;
                    user-select: none;
                }

                .drag-handle:hover {
                    color: #666;
                }

                .drag-handle:active {
                    cursor: grabbing;
                }

                .task-title {
                    flex: 1;
                    font-size: 16px;
                    cursor: pointer;
                    white-space: nowrap;
                    overflow: hidden;
                    text-overflow: ellipsis;
                    color: var(--fg);
                }

                .task-title.current {
                    color: var(--accent);
                }

                .indicator {
                    display: inline-block;
                    width: 20px;
                }

                /* Size gauge - visual bar indicator */
                .size-gauge {
                    display: flex;
                    align-items: center;
                    gap: 4px;
                    cursor: pointer;
                    position: relative;
                }

                .size-bar {
                    height: 12px;
                    background: linear-gradient(90deg, var(--accent) 0%, var(--accent) 100%);
                    opacity: 0.7;
                    transition: width 0.2s;
                }

                .size-bar.s { width: 10px; }
                .size-bar.m { width: 40px; }
                .size-bar.l { width: 100px; }

                .size-label {
                    font-size: 14px;
                    color: var(--fg);
                    min-width: 20px;
                    font-weight: bold;
                }

                .size-gauge:hover .size-bar {
                    opacity: 1;
                }

                .size-dropdown {
                    position: absolute;
                    top: 100%;
                    left: 0;
                    background: var(--bg);
                    border: 1px solid var(--border);
                    z-index: 100;
                    display: flex;
                    flex-direction: column;
                }

                .size-option {
                    padding: 4px 12px;
                    cursor: pointer;
                    display: flex;
                    align-items: center;
                    gap: 8px;
                    font-size: 12px;
                    color: var(--fg);
                }

                .size-option:hover {
                    background: var(--select-bg);
                }

                .size-option .bar {
                    height: 10px;
                    background: var(--accent);
                }

                /* Category select */
                .category-select {
                    background: var(--entry-bg);
                    border: 1px solid var(--border);
                    color: var(--fg);
                    padding: 2px 4px;
                    font-family: inherit;
                    font-size: 12px;
                    cursor: pointer;
                    outline: none;
                    -webkit-appearance: none;
                    -moz-appearance: none;
                    appearance: none;
                    border-radius: 0;
                    max-width: 80px;
                }

                .category-select:hover {
                    border-color: var(--muted);
                }

                .category-select option {
                    background: var(--entry-bg);
                    color: var(--fg);
                }

                .win-count {
                    color: var(--muted);
                    font-size: 14px;
                    min-width: 35px;
                    text-align: right;
                }

                .controls {
                    display: flex;
                    align-items: center;
                    gap: 4px;
                }

                .ctrl-btn {
                    color: #555;
                    cursor: pointer;
                    padding: 2px 4px;
                    font-size: 18px;
                    user-select: none;
                }

                .ctrl-btn:hover {
                    color: #888;
                }

                .ctrl-btn.select {
                    color: #888;
                    font-size: 14px;
                }

                .ctrl-btn.select:hover {
                    color: var(--accent);
                }

                .ctrl-btn.close {
                    color: var(--danger-dim);
                    font-size: 14px;
                }

                .ctrl-btn.close:hover {
                    color: var(--danger);
                }

                .confirm-bar {
                    display: flex;
                    align-items: center;
                    gap: 8px;
                }

                .confirm-bar .msg {
                    color: #ff6666;
                    font-size: 12px;
                }

                .confirm-bar .yes {
                    color: #ff6666;
                    cursor: pointer;
                }

                .confirm-bar .yes:hover {
                    color: #ff8888;
                }

                .confirm-bar .no {
                    color: #888;
                    cursor: pointer;
                }

                .confirm-bar .no:hover {
                    color: #aaa;
                }

                .ctrl-btn.edit {
                    color: #888;
                    font-size: 14px;
                }

                .ctrl-btn.edit:hover {
                    color: var(--accent);
                }

                .edit-input {
                    flex: 1;
                    background: var(--entry-bg);
                    border: 1px solid var(--accent);
                    color: var(--fg);
                    padding: 4px 8px;
                    font-family: inherit;
                    font-size: 14px;
                    outline: none;
                }

                .edit-bar {
                    display: flex;
                    align-items: center;
                    gap: 8px;
                }

                .edit-bar .save {
                    color: var(--accent);
                    cursor: pointer;
                    font-size: 14px;
                }

                .edit-bar .save:hover {
                    color: #88ccff;
                }

                .edit-bar .cancel {
                    color: #888;
                    cursor: pointer;
                    font-size: 14px;
                }

                .edit-bar .cancel:hover {
                    color: #aaa;
                }
            `;

            constructor() {
                super();
                this.categories = [];
                this.confirming = false;
                this.editing = false;
                this.editTitle = '';
                this.dragging = false;
                this.dragOver = false;
                this.sizePickerOpen = false;
            }

            _getCategoryColor() {
                if (!this.task.category || !this.categories) return 'transparent';
                const cat = this.categories.find(c => c.id === this.task.category);
                return cat ? cat.color : 'transparent';
            }

            render() {
                const title = this.task.title.length > 40
                    ? this.task.title.slice(0, 37) + '...'
                    : this.task.title;
                const catColor = this._getCategoryColor();

                return html`
                    <div class="task-row ${this.isSelected ? 'selected' : ''} ${this.dragging ? 'dragging' : ''} ${this.dragOver ? 'drag-over' : ''}"
                         style="border-left-color: ${catColor}"
                         draggable="${!this.editing}"
                         @dragstart=${this._onDragStart}
                         @dragend=${this._onDragEnd}
                         @dragover=${this._onDragOver}
                         @dragleave=${this._onDragLeave}
                         @drop=${this._onDrop}>
                        ${this.editing ? this._renderEditMode() : html`
                            <span class="drag-handle">⠿</span>
                            <span class="task-title ${this.isCurrent ? 'current' : ''}" @click=${this._onSelect}>
                                <span class="indicator">${this.isCurrent ? '▶' : ''}</span>
                                ${title}
                            </span>
                            ${this._renderSizeGauge()}
                            ${this._renderCategorySelect()}
                            <span class="win-count">${this.winCount}w</span>
                            ${this.confirming ? this._renderConfirm() : this._renderControls()}
                        `}
                    </div>
                `;
            }

            _renderSizeGauge() {
                const sizes = ['S', 'M', 'L'];
                const sizeWidths = { 'S': 10, 'M': 40, 'L': 100 };
                const currentSize = this.task.size || 'M';
                return html`
                    <div class="size-gauge" @click=${this._toggleSizePicker}>
                        <div class="size-bar ${currentSize.toLowerCase()}" title="Size: ${currentSize}"></div>
                        <span class="size-label">${currentSize}</span>
                        ${this.sizePickerOpen ? html`
                            <div class="size-dropdown">
                                ${sizes.map(s => html`
                                    <div class="size-option" @click=${(e) => this._selectSize(e, s)}>
                                        <div class="bar" style="width: ${sizeWidths[s]}px"></div>
                                        <span>${s}</span>
                                    </div>
                                `)}
                            </div>
                        ` : ''}
                    </div>
                `;
            }

            _toggleSizePicker(e) {
                e.stopPropagation();
                this.sizePickerOpen = !this.sizePickerOpen;
                if (this.sizePickerOpen) {
                    const close = () => {
                        this.sizePickerOpen = false;
                        document.removeEventListener('click', close);
                    };
                    setTimeout(() => document.addEventListener('click', close), 0);
                }
            }

            _selectSize(e, size) {
                e.stopPropagation();
                this.sizePickerOpen = false;
                this.dispatchEvent(new CustomEvent('task-size-change', {
                    detail: { taskId: this.task.id, size },
                    bubbles: true, composed: true
                }));
            }

            _renderCategorySelect() {
                const currentCat = this.task.category;
                return html`
                    <select class="category-select"
                            @change=${this._onCategoryChange}
                            @click=${e => e.stopPropagation()}>
                        <option value="" ?selected=${!currentCat}>--</option>
                        ${(this.categories || []).map(c => html`
                            <option value=${c.id} ?selected=${c.id === currentCat}
                                    style="color: ${c.color}">${c.name}</option>
                        `)}
                    </select>
                `;
            }

            _renderEditMode() {
                return html`
                    <input class="edit-input"
                           type="text"
                           .value=${this.editTitle}
                           @input=${e => this.editTitle = e.target.value}
                           @keydown=${this._onEditKeydown}
                           autofocus>
                    <div class="edit-bar">
                        <span class="save" @click=${this._onEditSave}>[Save]</span>
                        <span class="cancel" @click=${this._onEditCancel}>[Cancel]</span>
                    </div>
                `;
            }

            _renderControls() {
                return html`
                    <div class="controls">
                        <span class="ctrl-btn" @click=${this._onMoveUp}>↑</span>
                        <span class="ctrl-btn" @click=${this._onMoveDown}>↓</span>
                        <span class="ctrl-btn select" @click=${this._onSelect}>[Select]</span>
                        <span class="ctrl-btn edit" @click=${this._onEdit}>[Edit]</span>
                        <span class="ctrl-btn close" @click=${this._onClose}>[Close]</span>
                    </div>
                `;
            }

            _renderConfirm() {
                return html`
                    <div class="confirm-bar">
                        <span class="msg">Close ${this.winCount}w?</span>
                        <span class="yes" @click=${this._onConfirmYes}>[Yes]</span>
                        <span class="no" @click=${this._onConfirmNo}>[No]</span>
                    </div>
                `;
            }

            _onCategoryChange(e) {
                const val = e.target.value;
                const categoryId = val ? parseInt(val, 10) : null;
                this.dispatchEvent(new CustomEvent('task-category-change', {
                    detail: { taskId: this.task.id, categoryId },
                    bubbles: true, composed: true
                }));
            }

            _onDragStart(e) {
                this.dragging = true;
                e.dataTransfer.effectAllowed = 'move';
                e.dataTransfer.setData('text/plain', this.task.id.toString());
                this.dispatchEvent(new CustomEvent('drag-start', { detail: { taskId: this.task.id } }));
            }

            _onDragEnd() {
                this.dragging = false;
                this.dispatchEvent(new CustomEvent('drag-end'));
            }

            _onDragOver(e) {
                e.preventDefault();
                e.dataTransfer.dropEffect = 'move';
                this.dragOver = true;
            }

            _onDragLeave() {
                this.dragOver = false;
            }

            _onDrop(e) {
                e.preventDefault();
                this.dragOver = false;
                const draggedId = parseInt(e.dataTransfer.getData('text/plain'), 10);
                if (draggedId !== this.task.id) {
                    this.dispatchEvent(new CustomEvent('task-drop', {
                        detail: { draggedId, targetId: this.task.id },
                        bubbles: true, composed: true
                    }));
                }
            }

            _onSelect() {
                this.dispatchEvent(new CustomEvent('task-select', { detail: { taskId: this.task.id }, bubbles: true, composed: true }));
            }

            _onClose() {
                if (this.winCount > 0) {
                    this.confirming = true;
                } else {
                    this.dispatchEvent(new CustomEvent('task-close', { detail: { taskId: this.task.id }, bubbles: true, composed: true }));
                }
            }

            _onConfirmYes() {
                this.confirming = false;
                this.dispatchEvent(new CustomEvent('task-close', { detail: { taskId: this.task.id }, bubbles: true, composed: true }));
            }

            _onConfirmNo() {
                this.confirming = false;
            }

            _onMoveUp() {
                this.dispatchEvent(new CustomEvent('task-move-up', { detail: { taskId: this.task.id }, bubbles: true, composed: true }));
            }

            _onMoveDown() {
                this.dispatchEvent(new CustomEvent('task-move-down', { detail: { taskId: this.task.id }, bubbles: true, composed: true }));
            }

            _onEdit() {
                this.editTitle = this.task.title;
                this.editing = true;
                this.updateComplete.then(() => {
                    const input = this.shadowRoot.querySelector('.edit-input');
                    if (input) {
                        input.focus();
                        input.select();
                    }
                });
            }

            _onEditKeydown(e) {
                if (e.key === 'Enter') {
                    this._onEditSave();
                } else if (e.key === 'Escape') {
                    this._onEditCancel();
                }
            }

            _onEditSave() {
                if (this.editTitle.trim()) {
                    this.dispatchEvent(new CustomEvent('task-rename', {
                        detail: { taskId: this.task.id, newTitle: this.editTitle.trim() },
                        bubbles: true, composed: true
                    }));
                }
                this.editing = false;
            }

            _onEditCancel() {
                this.editing = false;
            }
        }
        customElements.define('task-row', TaskRow);

        // Predefined color palette
        const COLOR_PALETTE = [
            '#ff6666', '#ff9966', '#ffcc66', '#ffff66', '#ccff66',
            '#66ff66', '#66ffcc', '#66ffff', '#66ccff', '#6699ff',
            '#6666ff', '#9966ff', '#cc66ff', '#ff66ff', '#ff66cc',
            '#ff6699', '#888888', '#aaaaaa', '#cccccc', '#ffffff'
        ];

        // Color Picker Component
        class ColorPicker extends LitElement {
            static properties = {
                color: { type: String },
                open: { type: Boolean },
            };

            static styles = css`
                :host {
                    display: inline-block;
                    position: relative;
                }

                .color-btn {
                    width: 24px;
                    height: 24px;
                    border: 1px solid var(--border);
                    cursor: pointer;
                    padding: 0;
                }

                .color-btn:hover {
                    border-color: var(--muted);
                }

                .picker-popup {
                    position: absolute;
                    top: 28px;
                    left: 0;
                    background: var(--bg);
                    border: 1px solid var(--border);
                    padding: 4px;
                    display: grid;
                    grid-template-columns: repeat(5, 1fr);
                    gap: 2px;
                    z-index: 100;
                }

                .color-option {
                    width: 20px;
                    height: 20px;
                    border: 1px solid var(--border);
                    cursor: pointer;
                    padding: 0;
                }

                .color-option:hover {
                    border-color: var(--fg);
                }

                .color-option.selected {
                    border: 2px solid var(--accent);
                }
            `;

            constructor() {
                super();
                this.color = '#66aaff';
                this.open = false;
            }

            render() {
                return html`
                    <button class="color-btn"
                            style="background: ${this.color}"
                            @click=${this._togglePicker}></button>
                    ${this.open ? html`
                        <div class="picker-popup">
                            ${COLOR_PALETTE.map(c => html`
                                <button class="color-option ${c === this.color ? 'selected' : ''}"
                                        style="background: ${c}"
                                        @click=${() => this._selectColor(c)}></button>
                            `)}
                        </div>
                    ` : ''}
                `;
            }

            _togglePicker(e) {
                e.stopPropagation();
                this.open = !this.open;
                if (this.open) {
                    // Close on outside click
                    const close = () => {
                        this.open = false;
                        document.removeEventListener('click', close);
                    };
                    setTimeout(() => document.addEventListener('click', close), 0);
                }
            }

            _selectColor(color) {
                this.color = color;
                this.open = false;
                this.dispatchEvent(new CustomEvent('color-change', {
                    detail: { color },
                    bubbles: true, composed: true
                }));
            }
        }
        customElements.define('color-picker', ColorPicker);

        // Category Manager Component
        class CategoryManager extends LitElement {
            static properties = {
                categories: { type: Array },
                newName: { type: String },
                newColor: { type: String },
            };

            static styles = css`
                :host {
                    display: block;
                }

                .manager {
                    background: var(--bg);
                    border: 1px solid var(--border);
                    padding: 12px;
                    margin-bottom: 10px;
                }

                .header {
                    display: flex;
                    justify-content: space-between;
                    align-items: center;
                    margin-bottom: 10px;
                    padding-bottom: 8px;
                    border-bottom: 1px solid var(--border);
                }

                .header h3 {
                    margin: 0;
                    font-size: 14px;
                    font-weight: normal;
                }

                .close-btn {
                    color: var(--muted);
                    cursor: pointer;
                    font-size: 16px;
                }

                .close-btn:hover {
                    color: var(--fg);
                }

                .cat-list {
                    display: flex;
                    flex-direction: column;
                    gap: 6px;
                    margin-bottom: 10px;
                }

                .cat-item {
                    display: flex;
                    align-items: center;
                    gap: 8px;
                }

                .cat-name {
                    flex: 1;
                    background: var(--entry-bg);
                    border: 1px solid var(--border);
                    color: var(--fg);
                    padding: 4px 8px;
                    font-family: inherit;
                    font-size: 13px;
                    outline: none;
                }

                .cat-name:focus {
                    border-color: var(--accent);
                }

                .cat-delete {
                    color: var(--danger-dim);
                    cursor: pointer;
                    font-size: 14px;
                }

                .cat-delete:hover {
                    color: var(--danger);
                }

                .add-row {
                    display: flex;
                    align-items: center;
                    gap: 8px;
                    padding-top: 8px;
                    border-top: 1px solid var(--border);
                }

                .add-btn {
                    color: var(--accent);
                    cursor: pointer;
                    font-size: 14px;
                }

                .add-btn:hover {
                    color: #88ccff;
                }
            `;

            constructor() {
                super();
                this.categories = [];
                this.newName = '';
                this.newColor = '#66aaff';
            }

            render() {
                return html`
                    <div class="manager">
                        <div class="header">
                            <h3>Categories</h3>
                            <span class="close-btn" @click=${this._onClose}>×</span>
                        </div>
                        <div class="cat-list">
                            ${(this.categories || []).map(c => html`
                                <div class="cat-item">
                                    <color-picker .color=${c.color}
                                                  @color-change=${e => this._onUpdateColor(c.id, e.detail.color)}></color-picker>
                                    <input type="text" class="cat-name"
                                           .value=${c.name}
                                           @change=${e => this._onUpdateName(c.id, e.target.value)}>
                                    <span class="cat-delete" @click=${() => this._onDelete(c.id)}>[×]</span>
                                </div>
                            `)}
                        </div>
                        <div class="add-row">
                            <color-picker .color=${this.newColor}
                                          @color-change=${e => this.newColor = e.detail.color}></color-picker>
                            <input type="text" class="cat-name"
                                   placeholder="New category..."
                                   .value=${this.newName}
                                   @input=${e => this.newName = e.target.value}
                                   @keydown=${this._onNewKeydown}>
                            <span class="add-btn" @click=${this._onAdd}>[Add]</span>
                        </div>
                    </div>
                `;
            }

            _onClose() {
                this.dispatchEvent(new CustomEvent('close-manager', { bubbles: true, composed: true }));
            }

            _onUpdateColor(id, color) {
                const cat = this.categories.find(c => c.id === id);
                if (cat) {
                    this.dispatchEvent(new CustomEvent('update-category', {
                        detail: { id, name: cat.name, color },
                        bubbles: true, composed: true
                    }));
                }
            }

            _onUpdateName(id, name) {
                const cat = this.categories.find(c => c.id === id);
                if (cat && name.trim()) {
                    this.dispatchEvent(new CustomEvent('update-category', {
                        detail: { id, name: name.trim(), color: cat.color },
                        bubbles: true, composed: true
                    }));
                }
            }

            _onDelete(id) {
                this.dispatchEvent(new CustomEvent('delete-category', {
                    detail: { id },
                    bubbles: true, composed: true
                }));
            }

            _onAdd() {
                if (this.newName.trim()) {
                    this.dispatchEvent(new CustomEvent('add-category', {
                        detail: { name: this.newName.trim(), color: this.newColor },
                        bubbles: true, composed: true
                    }));
                    this.newName = '';
                    this.newColor = '#66aaff';
                }
            }

            _onNewKeydown(e) {
                if (e.key === 'Enter') {
                    this._onAdd();
                }
            }
        }
        customElements.define('category-manager', CategoryManager);

        // Main App Component
        class TaskApp extends LitElement {
            static properties = {
                tasks: { type: Array },
                categories: { type: Array },
                currentTaskId: { type: Number },
                selectedIndex: { type: Number },
                windowCounts: { type: Object },
                newTaskTitle: { type: String },
                filterMinSize: { type: String },
                filterMaxSize: { type: String },
                filterCategories: { type: Array },
                showCategoryManager: { type: Boolean },
            };

            static styles = css`
                :host {
                    display: flex;
                    flex-direction: column;
                    height: 100vh;
                    padding: 10px;
                }

                .top-bar {
                    display: flex;
                    gap: 10px;
                    margin-bottom: 10px;
                }

                .top-bar input[type="text"] {
                    flex: 1;
                    background: var(--entry-bg);
                    border: 1px solid var(--border);
                    color: var(--fg);
                    padding: 8px 12px;
                    font-family: inherit;
                    font-size: inherit;
                    outline: none;
                }

                .top-bar input[type="text"]:focus {
                    border-color: var(--accent);
                }

                .top-bar button {
                    background: var(--button-bg);
                    border: none;
                    color: var(--fg);
                    padding: 8px 16px;
                    font-family: inherit;
                    font-size: inherit;
                    cursor: pointer;
                }

                .top-bar button:hover {
                    background: var(--accent);
                    color: #000;
                }

                .filter-bar {
                    display: flex;
                    gap: 10px;
                    align-items: center;
                    margin-bottom: 10px;
                    flex-wrap: wrap;
                }

                .filter-group {
                    display: flex;
                    align-items: center;
                    gap: 4px;
                }

                .filter-label {
                    color: var(--muted);
                    font-size: 12px;
                }

                .filter-select {
                    background: var(--entry-bg);
                    border: 1px solid var(--border);
                    color: var(--fg);
                    padding: 4px 8px;
                    font-family: inherit;
                    font-size: 12px;
                    cursor: pointer;
                    outline: none;
                    -webkit-appearance: none;
                    -moz-appearance: none;
                    appearance: none;
                    border-radius: 0;
                }

                .filter-select:hover {
                    border-color: var(--muted);
                }

                .filter-select option {
                    background: var(--entry-bg);
                    color: var(--fg);
                }

                .cat-filter {
                    display: flex;
                    gap: 4px;
                    flex-wrap: wrap;
                }

                .cat-chip {
                    display: inline-flex;
                    align-items: center;
                    gap: 4px;
                    padding: 2px 8px;
                    border-radius: 10px;
                    font-size: 12px;
                    cursor: pointer;
                    border: 1px solid var(--border);
                    background: var(--entry-bg);
                    color: var(--muted);
                }

                .cat-chip.active {
                    border-color: var(--accent);
                    color: var(--fg);
                }

                .cat-chip .dot {
                    width: 8px;
                    height: 8px;
                    border-radius: 50%;
                }

                .manage-btn {
                    color: var(--muted);
                    cursor: pointer;
                    font-size: 12px;
                    margin-left: auto;
                }

                .manage-btn:hover {
                    color: var(--accent);
                }

                .task-list {
                    flex: 1;
                    overflow-y: auto;
                }

                .task-list::-webkit-scrollbar {
                    width: 8px;
                }

                .task-list::-webkit-scrollbar-track {
                    background: var(--bg);
                }

                .task-list::-webkit-scrollbar-thumb {
                    background: var(--border);
                    border-radius: 4px;
                }

                .task-list::-webkit-scrollbar-thumb:hover {
                    background: #444;
                }

                .no-tasks {
                    color: var(--muted);
                    text-align: center;
                    padding: 20px;
                }
            `;

            constructor() {
                super();
                this.tasks = [];
                this.categories = [];
                this.currentTaskId = null;
                this.selectedIndex = 0;
                this.windowCounts = {};
                this.newTaskTitle = '';
                this.filterMinSize = '';
                this.filterMaxSize = '';
                this.filterCategories = [];
                this.showCategoryManager = false;
                this._init();
            }

            async _init() {
                await api.readyPromise;
                await this._applyTheme();
                await this._refresh();
                this._startPolling();
                this._setupKeyboardShortcuts();
            }

            async _applyTheme() {
                const config = await api.getConfig();
                if (config?.theme) {
                    const root = document.documentElement;
                    const t = config.theme;
                    if (t.bg) root.style.setProperty('--bg', t.bg);
                    if (t.fg) root.style.setProperty('--fg', t.fg);
                    if (t.accent) root.style.setProperty('--accent', t.accent);
                    if (t.button_bg) root.style.setProperty('--button-bg', t.button_bg);
                    if (t.entry_bg) root.style.setProperty('--entry-bg', t.entry_bg);
                    if (t.select_bg) root.style.setProperty('--select-bg', t.select_bg);
                    if (t.border) root.style.setProperty('--border', t.border);
                }
            }

            async _refresh() {
                this.tasks = await api.getTasks() || [];
                this.categories = await api.getCategories() || [];
                this.currentTaskId = await api.getCurrentTaskId();

                const filtered = this._getFilteredTasks();
                if (this.selectedIndex >= filtered.length) {
                    this.selectedIndex = Math.max(0, filtered.length - 1);
                }

                const counts = {};
                for (const task of this.tasks) {
                    counts[task.id] = await api.getWindowCount(task.id) || 0;
                }
                this.windowCounts = counts;
            }

            _getFilteredTasks() {
                return this.tasks.filter(task => {
                    // Size filter
                    const taskSize = task.size || 'M';
                    const taskOrder = SIZE_ORDER[taskSize];

                    if (this.filterMinSize) {
                        const minOrder = SIZE_ORDER[this.filterMinSize];
                        if (taskOrder < minOrder) return false;
                    }

                    if (this.filterMaxSize) {
                        const maxOrder = SIZE_ORDER[this.filterMaxSize];
                        if (taskOrder > maxOrder) return false;
                    }

                    // Category filter
                    if (this.filterCategories.length > 0) {
                        if (!this.filterCategories.includes(task.category)) {
                            return false;
                        }
                    }

                    return true;
                });
            }

            _startPolling() {
                setInterval(async () => {
                    const newTasks = await api.getTasks() || [];
                    const newCategories = await api.getCategories() || [];
                    const newCurrentId = await api.getCurrentTaskId();

                    const tasksChanged = JSON.stringify(newTasks) !== JSON.stringify(this.tasks);
                    const catsChanged = JSON.stringify(newCategories) !== JSON.stringify(this.categories);

                    if (tasksChanged) {
                        this.tasks = newTasks;
                    }
                    if (catsChanged) {
                        this.categories = newCategories;
                    }
                    if (newCurrentId !== this.currentTaskId) {
                        this.currentTaskId = newCurrentId;
                    }

                    const filtered = this._getFilteredTasks();
                    if (this.selectedIndex >= filtered.length) {
                        this.selectedIndex = Math.max(0, filtered.length - 1);
                    }

                    const counts = {};
                    for (const task of this.tasks) {
                        counts[task.id] = await api.getWindowCount(task.id) || 0;
                    }
                    this.windowCounts = counts;
                }, 500);
            }

            _setupKeyboardShortcuts() {
                document.addEventListener('keydown', (e) => {
                    const isInInput = e.composedPath().some(el => el.tagName === 'INPUT');
                    const filtered = this._getFilteredTasks();

                    if (e.key === 'ArrowUp' && !isInInput) {
                        e.preventDefault();
                        if (this.selectedIndex > 0) this.selectedIndex--;
                    } else if (e.key === 'ArrowDown' && !isInInput) {
                        e.preventDefault();
                        if (this.selectedIndex < filtered.length - 1) this.selectedIndex++;
                    } else if (e.key === 'Enter') {
                        if (isInInput && this.newTaskTitle.trim()) {
                            this._addTask();
                        } else if (!isInInput && filtered.length > 0) {
                            this._selectTask(filtered[this.selectedIndex].id);
                        }
                    } else if (e.key === 'Delete' || (e.ctrlKey && e.key === 'd')) {
                        if (!isInInput && filtered.length > 0) {
                            e.preventDefault();
                            this._closeTask(filtered[this.selectedIndex].id);
                        }
                    } else if (e.ctrlKey && e.key === 'n') {
                        e.preventDefault();
                        const input = this.shadowRoot.querySelector('input[type="text"]');
                        input?.focus();
                    } else if (e.key === 'Escape') {
                        if (this.showCategoryManager) {
                            this.showCategoryManager = false;
                        } else if (this.newTaskTitle) {
                            this.newTaskTitle = '';
                        } else {
                            const input = this.shadowRoot.querySelector('input[type="text"]');
                            input?.blur();
                        }
                    }
                });
            }

            render() {
                const filtered = this._getFilteredTasks();

                return html`
                    <div class="top-bar">
                        <input
                            type="text"
                            placeholder="New task..."
                            .value=${this.newTaskTitle}
                            @input=${e => this.newTaskTitle = e.target.value}
                        >
                        <button @click=${this._addTask}>+</button>
                    </div>

                    <div class="filter-bar">
                        <div class="filter-group">
                            <span class="filter-label">Size:</span>
                            <select class="filter-select"
                                    .value=${this.filterMinSize}
                                    @change=${e => this.filterMinSize = e.target.value}>
                                <option value="">Min</option>
                                ${SIZES.map(s => html`<option value=${s}>${s}</option>`)}
                            </select>
                            <span class="filter-label">-</span>
                            <select class="filter-select"
                                    .value=${this.filterMaxSize}
                                    @change=${e => this.filterMaxSize = e.target.value}>
                                <option value="">Max</option>
                                ${SIZES.map(s => html`<option value=${s}>${s}</option>`)}
                            </select>
                        </div>

                        <div class="cat-filter">
                            ${this.categories.map(c => html`
                                <span class="cat-chip ${this.filterCategories.includes(c.id) ? 'active' : ''}"
                                      @click=${() => this._toggleCategoryFilter(c.id)}>
                                    <span class="dot" style="background: ${c.color}"></span>
                                    ${c.name}
                                </span>
                            `)}
                        </div>

                        <span class="manage-btn" @click=${() => this.showCategoryManager = !this.showCategoryManager}>
                            [${this.showCategoryManager ? 'Hide' : 'Categories'}]
                        </span>
                    </div>

                    ${this.showCategoryManager ? html`
                        <category-manager
                            .categories=${this.categories}
                            @close-manager=${() => this.showCategoryManager = false}
                            @add-category=${this._onAddCategory}
                            @update-category=${this._onUpdateCategory}
                            @delete-category=${this._onDeleteCategory}
                        ></category-manager>
                    ` : ''}

                    <div class="task-list"
                         @task-select=${this._onTaskSelect}
                         @task-close=${this._onTaskClose}
                         @task-move-up=${this._onTaskMoveUp}
                         @task-move-down=${this._onTaskMoveDown}
                         @task-drop=${this._onTaskDrop}
                         @task-rename=${this._onTaskRename}
                         @task-size-change=${this._onTaskSizeChange}
                         @task-category-change=${this._onTaskCategoryChange}>
                        ${filtered.length === 0 ? html`
                            <div class="no-tasks">No tasks${this.tasks.length > 0 ? ' (filtered)' : ''}</div>
                        ` : filtered.map((task, index) => html`
                            <task-row
                                .task=${task}
                                .categories=${this.categories}
                                .isCurrent=${task.id === this.currentTaskId}
                                .isSelected=${index === this.selectedIndex}
                                .winCount=${this.windowCounts[task.id] || 0}
                            ></task-row>
                        `)}
                    </div>
                `;
            }

            _toggleCategoryFilter(catId) {
                if (this.filterCategories.includes(catId)) {
                    this.filterCategories = this.filterCategories.filter(id => id !== catId);
                } else {
                    this.filterCategories = [...this.filterCategories, catId];
                }
            }

            async _addTask() {
                if (!this.newTaskTitle.trim()) return;
                await api.addTask(this.newTaskTitle.trim());
                this.newTaskTitle = '';
                await this._refresh();
            }

            async _selectTask(taskId) {
                await api.selectTask(taskId);
                await this._refresh();
            }

            async _closeTask(taskId) {
                await api.closeTask(taskId);
                await this._refresh();
            }

            async _onTaskSelect(e) {
                await this._selectTask(e.detail.taskId);
            }

            async _onTaskClose(e) {
                await this._closeTask(e.detail.taskId);
            }

            async _onTaskMoveUp(e) {
                await api.moveTaskUp(e.detail.taskId);
                await this._refresh();
            }

            async _onTaskMoveDown(e) {
                await api.moveTaskDown(e.detail.taskId);
                await this._refresh();
            }

            async _onTaskDrop(e) {
                const { draggedId, targetId } = e.detail;
                const targetIndex = this.tasks.findIndex(t => t.id === targetId);
                if (targetIndex >= 0) {
                    await api.reorderTask(draggedId, targetIndex);
                    await this._refresh();
                }
            }

            async _onTaskRename(e) {
                const { taskId, newTitle } = e.detail;
                await api.renameTask(taskId, newTitle);
                await this._refresh();
            }

            async _onTaskSizeChange(e) {
                const { taskId, size } = e.detail;
                await api.setTaskSize(taskId, size);
                await this._refresh();
            }

            async _onTaskCategoryChange(e) {
                const { taskId, categoryId } = e.detail;
                await api.setTaskCategory(taskId, categoryId);
                await this._refresh();
            }

            async _onAddCategory(e) {
                const { name, color } = e.detail;
                await api.addCategory(name, color);
                await this._refresh();
            }

            async _onUpdateCategory(e) {
                const { id, name, color } = e.detail;
                await api.updateCategory(id, name, color);
                await this._refresh();
            }

            async _onDeleteCategory(e) {
                const { id } = e.detail;
                await api.removeCategory(id);
                // Remove from filter if it was selected
                this.filterCategories = this.filterCategories.filter(cid => cid !== id);
                await this._refresh();
            }
        }
        customElements.define('task-app', TaskApp);
    </script>
</body>
</html>
